import 'package:geolocator/geolocator.dart';
import 'package:permission_handler/permission_handler.dart';
import 'dart:io' show Platform;

class LocationService {
  static const double casablancaLat = 33.5731;
  static const double casablancaLng = -7.5898;

  Future<Position?> getCurrentPosition() async {
    try {
      print('[LocationService] üöÄ Starting location request...');

      // Check if location services are enabled
      final serviceEnabled = await Geolocator.isLocationServiceEnabled();
      print('[LocationService] üìç Location services enabled: $serviceEnabled');

      if (!serviceEnabled) {
        print('[LocationService] ‚ùå Location services are disabled');
        return null;
      }

      // For Android 13+, we need to request permissions using permission_handler
      // for better compatibility with the new permission model
      if (Platform.isAndroid) {
        final hasPermission = await _requestAndroidLocationPermissions();
        if (!hasPermission) {
          print(
              '[LocationService] ‚ùå Could not get Android location permissions');
          return null;
        }
      } else {
        // iOS - use geolocator's built-in permission handling
        LocationPermission permission = await Geolocator.checkPermission();
        print('[LocationService] üîê Current permission: $permission');

        if (permission == LocationPermission.denied) {
          print('[LocationService] üîë Requesting location permission...');
          permission = await Geolocator.requestPermission();
          print('[LocationService] üîë Permission after request: $permission');

          if (permission == LocationPermission.denied) {
            print('[LocationService] ‚ùå Location permissions denied by user');
            return null;
          }
        }

        if (permission == LocationPermission.deniedForever) {
          print('[LocationService] ‚ùå Location permissions permanently denied');
          return null;
        }
      }

      print(
          '[LocationService] üì° Getting current position with mobile-data-friendly settings...');

      // Try multiple strategies for getting location, especially on mobile data
      Position? position = await _getLocationWithFallback();

      if (position != null) {
        print(
            '[LocationService] ‚úÖ Got position: ${position.latitude}, ${position.longitude}');
        return position;
      } else {
        print('[LocationService] ‚ùå Could not get location with any strategy');
        return null;
      }
    } catch (e, stackTrace) {
      print('[LocationService] ‚ùå Error getting location: $e');
      print('[LocationService] üìç Stack trace: $stackTrace');
      return null;
    }
  }

  // Mobile-data-friendly location fetching with fallback strategies
  Future<Position?> _getLocationWithFallback() async {
    try {
      // First, try to get last known location (fastest)
      print('[LocationService] üîç Trying last known location first...');
      try {
        final lastKnown = await Geolocator.getLastKnownPosition();
        if (lastKnown != null) {
          // Check if it's recent (within 5 minutes)
          final age = DateTime.now().difference(lastKnown.timestamp);
          if (age.inMinutes < 5) {
            print(
                '[LocationService] ‚ö° Using recent last known location (${age.inMinutes}m old)');
            return lastKnown;
          }
        }
      } catch (e) {
        print('[LocationService] ‚ö†Ô∏è Last known location not available: $e');
      }

      // Strategy 1: Try medium accuracy first (good for mobile data)
      print(
          '[LocationService] üéØ Trying medium accuracy (mobile-data friendly)...');
      try {
        final position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.medium, // More mobile-data friendly
          timeLimit:
              const Duration(seconds: 20), // Longer timeout for mobile data
        ).timeout(
          const Duration(seconds: 25),
          onTimeout: () => throw Exception('Medium accuracy timeout'),
        );

        print('[LocationService] ‚úÖ Got location with medium accuracy');
        return position;
      } catch (e) {
        print('[LocationService] ‚ö†Ô∏è Medium accuracy failed: $e');
      }

      // Strategy 2: Try low accuracy (fastest on mobile data)
      print(
          '[LocationService] üéØ Trying low accuracy (fastest on mobile data)...');
      try {
        final position = await Geolocator.getCurrentPosition(
          desiredAccuracy:
              LocationAccuracy.low, // Network-based, works well on mobile data
          timeLimit: const Duration(seconds: 30), // Even longer timeout
        ).timeout(
          const Duration(seconds: 35),
          onTimeout: () => throw Exception('Low accuracy timeout'),
        );

        print('[LocationService] ‚úÖ Got location with low accuracy');
        return position;
      } catch (e) {
        print('[LocationService] ‚ö†Ô∏è Low accuracy failed: $e');
      }

      // Strategy 3: Try high accuracy as last resort (best on WiFi)
      print(
          '[LocationService] üéØ Trying high accuracy (GPS-based, may be slow on mobile data)...');
      try {
        final position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.high,
          timeLimit: const Duration(seconds: 45), // Very long timeout for GPS
        ).timeout(
          const Duration(seconds: 50),
          onTimeout: () => throw Exception('High accuracy timeout'),
        );

        print('[LocationService] ‚úÖ Got location with high accuracy');
        return position;
      } catch (e) {
        print('[LocationService] ‚ö†Ô∏è High accuracy failed: $e');
      }

      // Strategy 4: Use any cached location if available
      print('[LocationService] üîç Trying any cached location as fallback...');
      try {
        final lastKnown = await Geolocator.getLastKnownPosition();
        if (lastKnown != null) {
          final age = DateTime.now().difference(lastKnown.timestamp);
          print(
              '[LocationService] ‚ö° Using cached location (${age.inMinutes}m old)');
          return lastKnown;
        }
      } catch (e) {
        print('[LocationService] ‚ö†Ô∏è No cached location available: $e');
      }

      print('[LocationService] ‚ùå All location strategies failed');
      return null;
    } catch (e) {
      print('[LocationService] ‚ùå Error in location fallback: $e');
      return null;
    }
  }

  // Android 13+ specific permission handling
  Future<bool> _requestAndroidLocationPermissions() async {
    try {
      print('[LocationService] ü§ñ Requesting Android location permissions...');

      // Check current permission status
      var fineLocationStatus = await Permission.location.status;
      var coarseLocationStatus = await Permission.locationWhenInUse.status;

      print('[LocationService] üîê Fine location status: $fineLocationStatus');
      print(
          '[LocationService] üîê Coarse location status: $coarseLocationStatus');

      // For Android 12+ (API 31+), we need to request both permissions together
      if (fineLocationStatus.isDenied || coarseLocationStatus.isDenied) {
        print('[LocationService] üîë Requesting location permissions...');

        // Request both fine and coarse location together for Android 12+
        Map<Permission, PermissionStatus> statuses = await [
          Permission.location,
          Permission.locationWhenInUse,
        ].request();

        fineLocationStatus =
            statuses[Permission.location] ?? PermissionStatus.denied;
        coarseLocationStatus =
            statuses[Permission.locationWhenInUse] ?? PermissionStatus.denied;

        print(
            '[LocationService] üîë Fine location after request: $fineLocationStatus');
        print(
            '[LocationService] üîë Coarse location after request: $coarseLocationStatus');
      }

      // Check if we got at least one location permission
      final hasLocationPermission = fineLocationStatus.isGranted ||
          coarseLocationStatus.isGranted ||
          fineLocationStatus.isLimited ||
          coarseLocationStatus.isLimited;

      if (!hasLocationPermission) {
        print('[LocationService] ‚ùå No location permissions granted');
        return false;
      }

      print('[LocationService] ‚úÖ Location permissions granted');
      return true;
    } catch (e) {
      print('[LocationService] ‚ùå Error requesting Android permissions: $e');
      return false;
    }
  }

  // Helper method to detect if running on emulator
  Future<bool> _isRunningOnEmulator() async {
    try {
      // Simple heuristic: assume emulator if we can't get location easily
      // In a real app, you might use device_info_plus for better detection
      if (Platform.isAndroid) {
        // Check if we can get location quickly (real devices usually can)
        try {
          final position = await Geolocator.getCurrentPosition(
            desiredAccuracy: LocationAccuracy.low,
            timeLimit: const Duration(seconds: 2),
          );

          // If we get a position very quickly, likely a real device
          // If lat/lng are exactly 0,0 or default emulator coords, likely emulator
          if (position.latitude == 0.0 && position.longitude == 0.0) {
            return true;
          }

          return false; // Got real coordinates quickly
        } catch (e) {
          // If we can't get location quickly, might be emulator
          return true;
        }
      }
      return false;
    } catch (e) {
      print('[LocationService] Could not determine emulator status: $e');
      return true; // Assume emulator if we can't determine (safer approach)
    }
  }

  // Provide emulator setup instructions
  void printEmulatorInstructions() {
    print('');
    print('üñ•Ô∏è ===== EMULATOR LOCATION SETUP =====');
    print('üí° If you\'re using Android Emulator:');
    print('üí° 1. Open Android Studio');
    print('üí° 2. In emulator, click "..." (more) button');
    print('üí° 3. Go to "Location" tab');
    print('üí° 4. Set location to:');
    print('üí°    - Google HQ: 37.422, -122.084');
    print('üí°    - Or search for a city');
    print('üí°    - Or use custom coordinates');
    print('üí° 5. Click "Send Location"');
    print('üí° 6. Restart the app');
    print('üñ•Ô∏è =====================================');
    print('');
  }

  Future<LocationData> getUserLocationOrDefault() async {
    try {
      print('[LocationService] üéØ Getting user location or default...');

      // Print helpful debug info for mobile data issues
      _printLocationTroubleshootingInfo();

      final position = await getCurrentPosition();

      if (position != null) {
        print('[LocationService] ‚úÖ Using real user location');
        return LocationData(
          latitude: position.latitude,
          longitude: position.longitude,
          isUserLocation: true,
        );
      } else {
        print('[LocationService] üìç Using default location (Casablanca)');
        _printLocationFailureHelp();

        // Return Casablanca as default
        return LocationData(
          latitude: casablancaLat,
          longitude: casablancaLng,
          isUserLocation: false,
        );
      }
    } catch (e) {
      print('[LocationService] ‚ùå Error in getUserLocationOrDefault: $e');
      return LocationData(
        latitude: casablancaLat,
        longitude: casablancaLng,
        isUserLocation: false,
      );
    }
  }

  // Helper method to print troubleshooting info
  void _printLocationTroubleshootingInfo() {
    print('');
    print('üìç ===== LOCATION TROUBLESHOOTING =====');
    print('üí° If location is not working:');
    print('üí° üì∂ WiFi vs Mobile Data:');
    print('üí°   ‚Ä¢ WiFi: Usually faster, uses network-assisted GPS');
    print('üí°   ‚Ä¢ 4G/5G: Slower, relies more on GPS satellites');
    print('üí°   ‚Ä¢ Make sure location services are enabled in Settings');
    print('üí° üîß Android Settings to check:');
    print('üí°   ‚Ä¢ Settings > Location > App permissions');
    print('üí°   ‚Ä¢ Settings > Location > Location accuracy (High accuracy)');
    print('üí°   ‚Ä¢ Settings > Location > Google Location Services');
    print('üí° ‚è±Ô∏è Mobile data location can take 30-60 seconds');
    print('üí° üè¢ Try going outside or near a window for better GPS signal');
    print('üìç =====================================');
    print('');
  }

  // Helper method to print failure help
  void _printLocationFailureHelp() {
    print('');
    print('‚ùå ===== LOCATION FAILED - TROUBLESHOOTING =====');
    print('üí° Common issues and solutions:');
    print('üí° üì∂ Mobile Data Issues:');
    print('üí°   ‚Ä¢ GPS takes longer on mobile data (30-60 seconds)');
    print('üí°   ‚Ä¢ Try moving outside or near a window');
    print('üí°   ‚Ä¢ Check if mobile data is working properly');
    print('üí° üîí Permission Issues:');
    print('üí°   ‚Ä¢ Go to Settings > Apps > CasaWonders > Permissions');
    print('üí°   ‚Ä¢ Enable Location permission');
    print('üí°   ‚Ä¢ Choose "While using the app" or "All the time"');
    print('üí° ‚öôÔ∏è Location Services:');
    print('üí°   ‚Ä¢ Settings > Location > Turn ON');
    print('üí°   ‚Ä¢ Settings > Location > Mode > High accuracy');
    print('üí° üåê Network Issues:');
    print('üí°   ‚Ä¢ Try switching between WiFi and mobile data');
    print('üí°   ‚Ä¢ Restart the app after switching networks');
    print('‚ùå =============================================');
    print('');
  }

  double calculateDistance(
    double lat1,
    double lon1,
    double lat2,
    double lon2,
  ) {
    return Geolocator.distanceBetween(lat1, lon1, lat2, lon2) / 1000; // km
  }

  Future<bool> hasLocationPermission() async {
    try {
      print('[LocationService] üîê Checking location permission...');

      if (Platform.isAndroid) {
        // Use permission_handler for Android 13+ compatibility
        final fineLocationStatus = await Permission.location.status;
        final coarseLocationStatus = await Permission.locationWhenInUse.status;

        print('[LocationService] üîê Fine location status: $fineLocationStatus');
        print(
            '[LocationService] üîê Coarse location status: $coarseLocationStatus');

        final hasPermission = fineLocationStatus.isGranted ||
            coarseLocationStatus.isGranted ||
            fineLocationStatus.isLimited ||
            coarseLocationStatus.isLimited;

        print('[LocationService] üîê Has permission: $hasPermission');
        return hasPermission;
      } else {
        // iOS - use geolocator
        final permission = await Geolocator.checkPermission();
        print('[LocationService] üîê Current permission: $permission');

        final hasPermission = permission == LocationPermission.always ||
            permission == LocationPermission.whileInUse;

        print('[LocationService] üîê Has permission: $hasPermission');
        return hasPermission;
      }
    } catch (e) {
      print('[LocationService] ‚ùå Error checking permission: $e');
      return false;
    }
  }

  Future<bool> requestLocationPermission() async {
    try {
      print('[LocationService] üîë Requesting location permission...');

      // First check if services are enabled
      final serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        print('[LocationService] ‚ùå Location services not enabled');
        return false;
      }

      if (Platform.isAndroid) {
        // Use Android 13+ compatible permission request
        return await _requestAndroidLocationPermissions();
      } else {
        // iOS - use geolocator
        final permission = await Geolocator.requestPermission();
        print('[LocationService] üîë Permission result: $permission');

        final granted = permission == LocationPermission.always ||
            permission == LocationPermission.whileInUse;

        print('[LocationService] üîë Permission granted: $granted');
        return granted;
      }
    } catch (e) {
      print('[LocationService] ‚ùå Error requesting permission: $e');
      return false;
    }
  }

  Future<void> openLocationSettings() async {
    await Geolocator.openLocationSettings();
  }

  Stream<Position> getPositionStream() {
    return Geolocator.getPositionStream(
      locationSettings: const LocationSettings(
        accuracy: LocationAccuracy.high,
        distanceFilter: 10, // meters
      ),
    );
  }
}

class LocationData {
  final double latitude;
  final double longitude;
  final bool isUserLocation;

  LocationData({
    required this.latitude,
    required this.longitude,
    required this.isUserLocation,
  });

  @override
  String toString() {
    return 'LocationData(lat: $latitude, lng: $longitude, isUser: $isUserLocation)';
  }
}
